
@Configuration
        //配置类==Spring配置文件
@ComponentScan("com.jason.lee.annotation")
        //可以自定义需要扫描的或排除的包、类


@Bean(name = "person")
        // 向Spring容器注册Bean，类型为方法返回值类型，id默认为方法名
@Lazy
        // 懒加载  针对singleton，容器启动时不创建Bean，第一次使用时创建并初始化
@Scope("prototype")
        // 默认singleton IOC容器启动时创建对象 （单例）
        // prototype 获取时创建对象
@Conditional 按照一定的条件判断，满足条件向容器注册Bean  (注解在类或方法上)


#############【注册组件】#############
1、包扫描 + 组件标注注解（@Controller、@Service、@Repository、@Component）
2、@Bean[导入第三方包中的组件]
3、@Import[快速导入组件]
    1）、@Import(Student.class)  //快速导入组件，id是默认全限定名
    2）、ImportSelector  //返回值就是导入容器的组件全类名
    3）、ImportBeanDefinitionRegistrar  //自定义注入Bean
4、使用Spring提供的FactoryBean（工厂Bean）
    // 实现FactoryBean接口


#############【Bean的生命周期】#############

【创建】
    单实例，在容器启动时创建对象
    多实例，在每次获取时创建对象
【初始化】
    对象创建完，对属性赋值，调用初始化方法
【销毁】
    单实例，容器关闭时
    多实例，容器不会管理多实例Bean，容器不会调用销毁方法

1）、指定初始化和销毁方法
        // @Bean(initMethod = "init", destroyMethod = "destroy")
2）、自定义Bean实现InitializingBean接口（初始化逻辑），实现DisposableBean接口（销毁逻辑）
        // public class Dog implements InitializingBean, DisposableBean
3）、@PostConstruct（初始化），@PreDestroy（销毁）

4）、BeanPostProcessor：后置处理器
        // postProcessBeforeInitialization：初始化方法执行之前
        // postProcessAfterInitialization：初始化方法执行之后
        ***Spring底层BeanPostProcessor的应用***

#############【Bean注入】#############
1）、@Value属性赋值
        // @Value("lee")
        // @Value("${people.nickName}")  从properties中获取值
        // @Value("#{20-2}")

2）、自动注入  AutowiredAnnotationBeanPostProcessor解析完成自动装配功能
    @Autowired   默认类型装配，若存在多个相同类型的组件，再将属性名作为id去装配 【可以用在构造器、方法、方法参数、属性，默认使用容器中的Bean】
        @Qualifier 搭配@Autowired使用,指定组件id
    @Resource java规范，默认按名称装配--->按类型装配
    @Inject java规范

3）、自定义组件使用Spring底层的组件（ApplicationContext、BeanFactory...）
        自定义组件实现XXXAware：在创建对象时，调用接口规定的方法注入相关的组件
                // ApplicationContextAware、BeanNameAware、ServletConfigAware...  （由XXXAwareProcessor完成）


#############【环境切换】#############
@Profile:
    Spring提供的可以根据当前环境，动态的激活和切换一系列组件的功能 【可以用在类、Bean组件上】

    @Profile("test")、 @Profile("dev")
    激活方式：
        虚拟机参数：-Dspring.profiles.active=dev
        代码方式： applicationContext.getEnvironment().setActiveProfiles("test");


#############【AOP的使用】#############
1、将业务逻辑组件和切面类都加入到容器中，@Aspect注解标注切面类
2、切面类中定义通知 @Before、 @After、 @AfterReturning、 @AfterThrowing、@Around，并定义切入点 @Pointcut
3、开启基于注解的AOP模式 @EnableAspectJAutoProxy


#############【AOP的原理】#############
1、@EnableAspectJAutoProxy 开启AOP功能
    @Import(AspectJAutoProxyRegistrar.class)  向容器中导入AspectJAutoProxyRegistrar组件
        利用AspectJAutoProxyRegistrar自定义给容器注册Bean：
                id：org.springframework.aop.config.internalAutoProxyCreator
                类型：AnnotationAwareAspectJAutoProxyCreator
2、AnnotationAwareAspectJAutoProxyCreator 后置处理器
    容器启动时：
        1）、registerBeanPostProcessors注册后置处理器，创建AnnotationAwareAspectJAutoProxyCreator对象
        2）、finishBeanFactoryInitialization创建剩下的实例
            [1] 创建业务逻辑组件和切面组件
            [2] AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程
            [3] 组件创建完，判断组件是否需要增强 postProcessAfterInitialization.wrapIfNecessary
                    需要增强：將切面的通知方法包装成增强器（Advisor），并创建代理对象
        3）、执行目标方法
             代理对象执行目标方法
                CglibAopProxy.intercept()获取目标方法的拦截器链，利用拦截器链的链式机制依次进入拦截器执行
                    [1] 正常：前置通知->目标方法->后置通知->返回通知
                    [2] 异常：前置通知->目标方法->后置通知->异常通知



#############【事务的原理】#############
1、@EnableTransactionManagement   // 开启基于注解的事务管理功能
        利用TransactionManagementConfigurationSelector向容器注册组件
            AutoProxyRegistrar
            ProxyTransactionManagementConfiguration
2、AutoProxyRegistrar
        注册InfrastructureAdvisorAutoProxyCreator （后置处理器）
        利用后置处理器机制在对象创建之后包装对象，返回一个代理对象（增强器）
3、ProxyTransactionManagementConfiguration
        注册事务增强器：
                1）、事务增强器要用事务注解的信息：AnnotationTransactionAttributeSource解析事务注解
                2）、事务拦截器：TransactionInterceptor 保存了事务的属性信息，事务管理器
                        目标方法执行时：先获取事务相关的属性；
                                       再获取PlatformTransactionManager；
                                       执行目标方法（如果异常，获取事务管理器进行回滚）

#############【扩展】#############
BeanPostProcessor：bean创建对象初始化前后进行拦截工作
【1】BeanFactoryPostProcessor：在BeanFactory标准初始化之后调用，所有的bean定义已经保存加载到beanFactory，此时bean实例未创建
      1、IOC容器创建
      2、invokeBeanFactoryPostProcessors(beanFactory)，执行BeanFactoryPostProcessor
              如何找到所有的BeanFactoryPostProcessor并执行其方法
                  1）、在beanFactory中找到所有BeanFactoryPostProcessor的组件，并执行
                          beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false)
                  2）、在初始化创建其他组件之前

 BeanDefinitionRegistryPostProcessor：优于BeanFactoryPostProcessor执行，可以利用该接口向容器增加组件


【2】ApplicationListener：监听容器中发布的事件，事件驱动开发
      1）、创建监听器监听事件（ApplicationEvent及其下面的子事件）
           或使用 @EventListener：
                                    使用EventListenerMethodProcessor处理器解析方法上的@EventListener
                                            1]、创建容器并refresh()
                                            2]、finishBeanFactoryInitialization(beanFactory) 初始化剩下的单实例Bean
                                                    1）、先创建所有的单实例Bean：getBean(beanName)
                                                    2）、获取所有创建完成的单实例Bean，判断是否是SmartInitializingSingleton类型
                                                            如果是就调用afterSingletonsInstantiated方法根据注解信息创建listener加入容器
      2）、监听器加入容器
      3）、只要容器中相关事件发布，监听器就能作用
              ContextRefreshedEvent：容器刷新完成（所有bean完全创建）
              ContextClosedEvent：关闭容器
      4）、发布事件
              applicationContext.publishEvent

 事件发布publishEvent(..)
               发布流程：
                   1）、获取事件多播器（派发器）getApplicationEventMulticaster()
                            事件多播器ApplicationEventMulticaster
                                      1、创建容器，refresh()
                                      2、initApplicationEventMulticaster()：初始化ApplicationEventMulticaster
                   2）、multicastEvent派发事件
                           获取所有的ApplicationListener： 1、如果有Executor，可以异步派发
                                                          2、否则同步直接执行listener方法
